# CPU 分析

## 平均负载

- 执行 top 或者 uptime 命令，可以看到如下信息

  ```bash
    21:40  up 44 days, 49 mins, 3 users, load averages: 2.45 3.11 3.40
  ```

- 信息含义

  - 当前时间
  - 系统运行时间
  - 正在登录用户数
  - 过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）
    - 简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数
      - 可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程
      - 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程
    - 但它实际上是活跃进程数的指数衰减平均值

- 注意
  - 平均负载高有可能是 CPU 密集型进程导致的
  - 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了
  - 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源

## 上下文切换

- 进程上下文切换

  - 系统调用，完成从用户态到内核态的转变

    - CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码
    - CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务
    - 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换

  - 进程间切换

    - 从一个进程切换到另一个进程运行
    - 在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈
    - 进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态

- 线程上下文切换

  - 前后两个线程属于不同进程
    - 因为资源不共享，所以切换过程就跟进程上下文切换是一样
  - 前后两个线程属于同一个进程
    - 因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据

- 中断上下文切换

  - 中断上下文切换并不涉及到进程的用户态
    - 即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等
  - 上半部
    - 用来快速处理中断,主要处理跟硬件紧密相关的或时间敏感的工作
  - 下半部
    - 延迟处理上半部未完成的工作，通常以内核线程的方式运行；通过软中断信号通知

- 查看系统的上下文切换情况

  - 通过 vmstat 查看系统总体的上下文切换
  - 通过 pidstat 查看进程切换详情
    - cswch：自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换
    - nvcswch：非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换

- 问题分析

  - 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题
  - 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈
  - 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型

## 进程调度时机

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序

## CPU 使用率

- CPU 使用率 = 1 - 空闲时间 / 总 CPU 时间
- 平均 CPU 使用率 = (空闲时间 2 - 空闲时间 1) / (总 CPU 时间 2 - 总 CPU 时间 1)
  - 性能工具一般都会取间隔一段时间（比如 3 秒）的两次值
- 常用的性能分析工具
  - top/htop 显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况
  - ps 显示了每个进程的资源使用情况

# 工具

- stress Linux 系统压力测试工具

  - stress --cpu 1 --timeout 600
  - stress -i 1 --timeout 600
  - stress -c 8 --timeout 600

- sysbench 多线程的基准测试工具

  - sysbench --threads=10 --max-time=300 threads run

- sysstat 包含了常用的 Linux 性能工具

  - mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标
    - mpstat -P ALL 5 20
  - pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标
    - pidstat -u 5 1
    - pidstat -w 5
    - pidstat -wt 1

- vmstat 一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数

  - 命令：vmstat 5
  - 信息解读
    - cs（context switch）是每秒上下文切换的次数
    - in（interrupt）则是每秒中断的次数
    - r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数
    - b（Blocked）则是处于不可中断睡眠状态的进程数

- perf

  - 以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题
  - 命令
    - perf top
    - perf record/report

- ab

  - apache bench, 常用的 HTTP 服务性能测试工具
  - ab -c 10 -n 100 your_url:port 并发 10 个请求测试 Nginx 性能，总共测试 100 个请求

- dstat

  - 系统资源使用分析，如磁盘

- strace

  - 跟踪进程系统调用
